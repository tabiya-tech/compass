from typing import List, Optional, Any
from uuid import uuid4

from pydantic import BaseModel, Field, field_serializer, field_validator

from app.agent.experience.timeline import Timeline
from app.agent.experience.work_type import WorkType
from app.vector_search.esco_entities import SkillEntity, OccupationSkillEntity


class ResponsibilitiesData(BaseModel):
    """
    A model for the collected data of the Skill Explorer Agent.
    The data are collected during the conversation and stored in the agent's state.
    They represent the following types of entities:
        - responsibilities:
        - skills
        - duties
        - tasks
        - actions
        - behaviour
        - activities
        - competencies
        - knowledge
    """

    responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as part of what they do for a given job.
    """

    non_responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as not part of what they do for a given job.
    """

    other_peoples_responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as part of what other people do for a given job.
    """

    class Config:
        """
        Disallow extra fields in the model
        """
        extra = "forbid"


class BaseExperienceEntity(BaseModel):
    """
    A simplified version of ExperienceEntity for a response
    """

    uuid: str
    """
    Unique identifier for the experience that allows to distinguish between different experiences..
    """

    experience_title: str
    """
    Title of the experience as the user refers to it (e.g. "Crew Member")
    """

    company: Optional[str] = None
    """
    Company name (e.g. "at McDonald's")
    """

    location: Optional[str] = None
    """
    Location of the experience (e.g. "Cape Town, South Africa")
    """

    timeline: Optional[Timeline] = None
    """
    Start and end date of the experience
    """

    work_type: Optional[WorkType] = None
    """
    Type of work (e.g. "waged-employee")
    """

    top_skills: List[SkillEntity] = Field(default_factory=list)
    """
    List of skills identified as relevant to the experience.
    It should not contain duplicates.
    """

    summary: Optional[str] = None
    """
    A summary of the experience, generated by the ExperienceSummarizer.
    This is a human-readable string that summarizes the experience.
    """

    deleted: bool = False
    """
    Flag indicating if the experience has been deleted
    """

    # use a field serializer to serialize the work_type
    # we use the name of the Enum instead of the value because that makes the code less brittle
    @field_serializer("work_type")
    def serialize_work_type(self, work_type: WorkType, _info):
        if work_type is not None:
            return work_type.name
        return None

    # Deserialize the work_type from the enum name
    @field_validator("work_type", mode='before')
    def deserialize_work_type(cls, value: Any) -> WorkType:
        if isinstance(value, str):
            return WorkType[value]
        return value


class ExperienceEntity(BaseExperienceEntity):
    """
    A class to represent the entities extracted from the conversation with the user,
    that can be used in downstream tasks.
    """
    # contextual_title: Optional[str] = None  # TODO: replace with the cluster_results from the ExperiencePipelineResponse
    # """
    # Title of the experience that is based on the experience title
    # and the additional context the user provided (e.g. "Fast Food Restaurant Staff")
    # """

    responsibilities: ResponsibilitiesData
    """
    List of responsibilities mentioned by the user while describing the experience
    It may contain duplicate entries as the user may mention the same task or skill multiple times
    """

    esco_occupations: List[OccupationSkillEntity]  # TODO: replace with the cluster_results from the ExperiencePipelineResponse
    """
    List of esco occupations and their skills (from the esco model) that match the experience.
    It should not contain duplicates.
    """

    questions_and_answers: List[tuple[str, str]]
    """
    List of questions the user answered during the conversation
    Each tuple contains a question and the user's answer.
    """

    class Config:
        extra = "forbid"

    def __init__(self, *,
                 experience_title: str,
                 company: Optional[str] = None,
                 location: Optional[str] = None,
                 timeline: Optional[Timeline] = None,
                 work_type: Optional[WorkType] = None,
                 uuid: Optional[str] = None,
                 responsibilities: Optional[ResponsibilitiesData] = None,
                 esco_occupations: Optional[List[OccupationSkillEntity]] = None,
                 questions_and_answers: Optional[List[tuple[str, str]]] = None,
                 summary: Optional[str] = None,
                 top_skills: Optional[List[SkillEntity]] = None,
                 deleted: bool = False
                 ):
        super().__init__(
            uuid=uuid if uuid is not None else str(uuid4()),  # Generate a unique UUID for each instance
            experience_title=experience_title,
            company=company,
            location=location,
            timeline=timeline,
            work_type=work_type,
            responsibilities=responsibilities if responsibilities is not None else ResponsibilitiesData(),
            esco_occupations=esco_occupations if esco_occupations is not None else [],
            questions_and_answers=questions_and_answers if questions_and_answers is not None else [],
            summary=summary,
            top_skills=top_skills if top_skills is not None else [],
            deleted=deleted,
        )

    @staticmethod
    def get_structured_summary(*, experience_title: str,
                               location: Optional[str] = None,
                               work_type: Optional[str] = None,
                               start_date: Optional[str] = None,
                               end_date: Optional[str] = None,
                               company: Optional[str] = None) -> str:
        date_part: str
        if start_date is not None and start_date != "":
            date_part = f", {start_date}" + f" - {end_date}" if end_date is not None and end_date != "" else ""
        else:
            date_part = f", until {end_date}" if end_date is not None and end_date != "" else ""
        company_part = f", {company}" if company is not None and company != "" else ""
        location_part = f", {location}" if location is not None and location != "" else ""
        _work_type = WorkType.from_string_key(work_type)
        work_type_part = f" ({WorkType.work_type_short(_work_type)})" if _work_type is not None else ""
        experience_title_part = experience_title if experience_title is not None else "No title provided yet"
        return experience_title_part + work_type_part + date_part + company_part + location_part + "\n"
