from typing import List, Optional, Any, TypeVar, Generic
from uuid import uuid4

from pydantic import BaseModel, Field, field_serializer, field_validator

from app.agent.experience.timeline import Timeline
from app.agent.experience.work_type import WorkType
from app.vector_search.esco_entities import SkillEntity, OccupationSkillEntity
from app.i18n.translation_service import t


class ResponsibilitiesData(BaseModel):
    """
    A model for the collected data of the Skill Explorer Agent.
    The data are collected during the conversation and stored in the agent's state.
    They represent the following types of entities:
        - responsibilities:
        - skills
        - duties
        - tasks
        - actions
        - behaviour
        - activities
        - competencies
        - knowledge
    """

    responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as part of what they do for a given job.
    """

    non_responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as not part of what they do for a given job.
    """

    other_peoples_responsibilities: list[str] = Field(default_factory=list)
    """
    Everything the user considers as part of what other people do for a given job.
    """

    class Config:
        """
        Disallow extra fields in the model
        """
        extra = "forbid"


# TypeVar for SkillEntity, allowing it to be used in generic types
SkillEntityT = TypeVar('SkillEntityT', bound=SkillEntity)


class ExperienceEntity(BaseModel, Generic[SkillEntityT]):
    """
    A simplified version of ExperienceEntity for a response
    """

    uuid: str
    """
    Unique identifier for the experience that allows to distinguish between different experiences..
    """

    experience_title: str
    """
    Title of the experience as the user refers to it (e.g. "Crew Member")
    """

    company: Optional[str] = None
    """
    Company name (e.g. "at McDonald's")
    """

    
    timeline: Optional[Timeline] = None
    """
    Start and end date of the experience
    """

    work_type: Optional[WorkType] = None
    """
    Type of work (e.g. "waged-employee")
    """

    top_skills: List[SkillEntityT] = Field(default_factory=list)
    """
    List of skills identified as relevant to the experience. (Taxonomy skills)
    It should not contain duplicates.
    """

    remaining_skills: List[SkillEntityT] = Field(default_factory=list)
    """
    The remaining skills that the LLM did not find as the top skills but are relevant to the experience
    """

    summary: Optional[str] = None
    """
    A summary of the experience, generated by the ExperienceSummarizer.
    This is a human-readable string that summarizes the experience.
    """

    # contextual_title: Optional[str] = None  # TODO: replace with the cluster_results from the ExperiencePipelineResponse
    # """
    # Title of the experience that is based on the experience title
    # and the additional context the user provided (e.g. "Fast Food Restaurant Staff")
    # """

    responsibilities: ResponsibilitiesData
    """
    List of responsibilities mentioned by the user while describing the experience
    It may contain duplicate entries as the user may mention the same task or skill multiple times
    """

    esco_occupations: List[
        OccupationSkillEntity]  # TODO: replace with the cluster_results from the ExperiencePipelineResponse
    """
    List of esco occupations and their skills (from the esco model) that match the experience.
    It should not contain duplicates.
    """

    questions_and_answers: List[tuple[str, str]]
    """
    List of questions the user answered during the conversation
    Each tuple contains a question and the user's answer.
    """

    # use a field serializer to serialize the work_type
    # we use the name of the Enum instead of the value because that makes the code less brittle
    @field_serializer("work_type")
    def serialize_work_type(self, work_type: WorkType, _info):
        if work_type is not None:
            return work_type.name
        return None

    # Deserialize the work_type from the enum name
    @field_validator("work_type", mode='before')
    def deserialize_work_type(cls, value: Any) -> WorkType:
        if isinstance(value, str):
            return WorkType[value]
        return value

    class Config:
        extra = "forbid"

    def __init__(self, *,
                 experience_title: str,
                 company: Optional[str] = None,
                 timeline: Optional[Timeline] = None,
                 work_type: Optional[WorkType] = None,
                 uuid: Optional[str] = None,
                 responsibilities: Optional[ResponsibilitiesData] = None,
                 esco_occupations: Optional[List[OccupationSkillEntity]] = None,
                 questions_and_answers: Optional[List[tuple[str, str]]] = None,
                 summary: Optional[str] = None,
                 top_skills: Optional[List[SkillEntity]] = None,
                 remaining_skills: Optional[List[SkillEntity]] = None,
                 ):
        super().__init__(
            uuid=uuid if uuid is not None else str(uuid4()),  # Generate a unique UUID for each instance
            experience_title=experience_title,
            company=company,
            timeline=timeline,
            work_type=work_type,
            responsibilities=responsibilities if responsibilities is not None else ResponsibilitiesData(),
            esco_occupations=esco_occupations if esco_occupations is not None else [],
            questions_and_answers=questions_and_answers if questions_and_answers is not None else [],
            summary=summary,
            top_skills=top_skills if top_skills is not None else [],
            remaining_skills=remaining_skills if remaining_skills is not None else []
        )

    @staticmethod
    def _tr_work_type_short(work_type: Optional[WorkType]) -> str:
        """Return a localized short label for a WorkType with safe fallback.

        We purposefully do not change WorkType.work_type_short() to avoid affecting
        system prompts; only UI/user-facing strings use this helper.
        """
        if work_type is None:
            return ""
        # Keys under: messages.experience.work_type.short.<enum_name_lower>
        key = WorkType.work_type_short_i18n_key(work_type)
        return t("messages",key)


    @staticmethod
    def get_structured_summary(*, experience_title: str,
                               work_type: Optional[str] = None,
                               start_date: Optional[str] = None,
                               end_date: Optional[str] = None,
                               company: Optional[str] = None) -> str:
        date_part: str
        if start_date is not None and start_date != "":
            date_part = f", {start_date}" + f" - {end_date}" if end_date is not None and end_date != "" else ""
        else:
            if end_date is not None and end_date != "":
                # Localize "until {end_date}" pattern
                _until = t("messages", "experience.until", f"until {end_date}", end_date=end_date)
                date_part = f", {_until}"
            else:
                date_part = ""
        company_part = f", {company}" if company is not None and company != "" else ""
        _work_type = WorkType.from_string_key(work_type)
        work_type_part = f" ({ExperienceEntity._tr_work_type_short(_work_type)})" if _work_type is not None else ""
        if experience_title is not None:
            experience_title_part = experience_title
        else:
            experience_title_part = t("messages", "experience.noTitleProvidedYet")
        return experience_title_part + work_type_part + date_part + company_part + "\n"
