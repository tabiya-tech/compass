from enum import Enum
from typing import Optional
from datetime import datetime, timezone
from bson import ObjectId

from pydantic import BaseModel, Field, field_validator, field_serializer


class AgentType(Enum):
    """
    An enumeration for agent types
    """
    WELCOME_AGENT = "WelcomeAgent"
    EXPLORE_EXPERIENCES_AGENT = "ExploreExperiencesAgentDirector"
    COLLECT_EXPERIENCES_AGENT = "CollectExperiencesAgent"
    INFER_OCCUPATIONS_AGENT = "InferOccupationsAgent"
    EXPLORE_SKILLS_AGENT = "ExploreSkillsAgent"
    PREFERENCE_ELICITATION_AGENT = "PreferenceElicitationAgent"
    FAREWELL_AGENT = "FarewellAgent"
    QNA_AGENT = "QnaAgent"


class AgentInput(BaseModel):
    """
    The input to an agent
    """
    # We don't have a separate collection for messages yet, so we have to assign an id here
    message_id: Optional[str] = Field(default_factory=lambda: str(ObjectId()))
    """A unique id for the message"""

    message: str  # Bad idea, rename
    """The message from the user"""

    is_artificial: Optional[bool] = False
    """
    Whether the message is artificial or not.
    Artificial messages are generated by the system impersonating the user. They are used to guide the conversation and should not be shown to the user.
    """
    sent_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    """The sent_at of the message"""

    class Config:
        extra = "forbid"

    # Serialize the sent_at datetime to ensure it's stored as UTC
    @field_serializer("sent_at")
    def serialize_sent_at(self, sent_at: datetime) -> str:
        return sent_at.isoformat()

    # Deserialize the sent_at datetime and ensure it's interpreted as UTC
    @field_validator("sent_at", mode='before')
    def deserialize_sent_at(cls, value: str | datetime) -> datetime:
        if isinstance(value, str):
            dt = datetime.fromisoformat(value)
        else:
            dt = value
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)


class LLMStats(BaseModel):
    """
    The stats for an LLM call
    """
    error: str = ""
    """The error message if there was an error"""

    prompt_token_count: int
    """The number of tokens in the prompt sent to the LLM"""

    response_token_count: int
    """The number of tokens in the response generated by the LLM"""

    response_time_in_sec: float
    """The time it took to generate the response, it may include multiple retries"""

    class Config:
        extra = "forbid"


class AgentOutput(BaseModel):
    """
    The output of an agent
    """
    message_id: Optional[str] = Field(default_factory=lambda: str(ObjectId()))
    """A unique id for the message"""

    message_for_user: str
    """The message for the user"""

    finished: bool
    """Whether the the agent has finished its task"""

    agent_type: Optional[AgentType] = None
    """The type of the agent that produced the response"""

    agent_response_time_in_sec: float
    """The total time it took the agent to produce a response. It may include multiple calls to LLMs or tools"""

    llm_stats: list[LLMStats]
    """The stats for each call to an LLM that was used to generate the response"""

    sent_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    """The sent_at of the message"""

    class Config:
        extra = "forbid"


    # use a field serializer to serialize the agent_type
    # we use the name of the Enum instead of the value because that makes the code less brittle
    @field_serializer("agent_type")
    def serialize_agent_type(self, agent_type: AgentType, _info):
        if agent_type is not None:
            return agent_type.name

    # Deserialize the agent_type from the enum name
    @field_validator("agent_type", mode='before')
    def deserialize_agent_type(cls, value: AgentType | str) -> AgentType:
        if isinstance(value, str):
            return AgentType[value]
        return value

    # Serialize the sent_at datetime to ensure it's stored as UTC
    @field_serializer("sent_at")
    def serialize_sent_at(self, sent_at: datetime) -> str:
        return sent_at.isoformat()

    # Deserialize the sent_at datetime and ensure it's interpreted as UTC
    @field_validator("sent_at", mode='before')
    def deserialize_sent_at(cls, value: str | datetime) -> datetime:
        if isinstance(value, str):
            dt = datetime.fromisoformat(value)
        else:
            dt = value
        return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)


class AgentOutputWithReasoning(AgentOutput):
    """
    The output of an agent with reasoning
    """
    reasoning: str
    """Chain of Thought reasoning behind the response of the LLM"""

    class Config:
        extra = "forbid"
