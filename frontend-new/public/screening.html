<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" href="/favicon.svg" />

  <title>Compass | Screening</title>

  <!-- Pre-connect for faster font loading -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">

  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, interactive-widget=resizes-content" />
  <link rel="apple-touch-icon" href="/compass.svg" />

  <!--
    Google Fonts: Inter and IBM Plex Mono
     We are loading the fonts with the media="print" attribute and changing it to "all" when the font is loaded.
     We do this to avoid blocking the rendering of the page while the font is being loaded.
     If javascript is disabled, the font will still load, but the page will be blocked until it is loaded.
  -->

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"
        media="print" onload="this.media='all'">
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,300;0,500;0,600;0,700;1,300&display=swap"
    rel="stylesheet" media="print" onload="this.media='all'">
  <noscript>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,300;0,500;0,600;0,700;1,300&display=swap"
      rel="stylesheet">
  </noscript>

  <script defer src="/data/env.js"></script>
  <script defer src="https://browser.sentry-cdn.com/8.28.0/bundle.tracing.replay.feedback.min.js"
          crossorigin="anonymous"></script>

  <style>
      /* Colors */
      :root {
          --dark-blue: #002147;
          --primary: #00FF91;
          --foreground: #41403D;
          --consent-checkbox-size: 18px;
          --consent-checkbox-gap: 12px;
      }

      * {
          font-family: Inter, sans-serif;
          /*color: var(--foreground);*/
      }

      html {
          overflow: hidden;
      }

      body, html {
          padding: 0;
          margin: 0;
          max-height: 100vh;
          font-size: 16px;
      }

      iframe {
          border: none;
          margin: 0;
          padding: 0;
      }

      .container {
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          min-height: 100vh;
      }

      /*Use more horizontal space in desktop/tab mode*/
      .section-container {
          max-width: 50dvw;
          padding: 8px;

          /*  SCROLL BEHAVIOUR  */
          overflow-y: auto;
          /*
            The scrollable height, is the full width - 100px which is the width of the logo image.
            Since the image is sticky.
          */
          max-height: calc(100dvh - 100px);
      }

      /*full width on mobile mode since we dont have space to waste*/
      @media (max-width: 768px) {
          .section-container {
              max-width: 100%;
          }
      }

      .content .title {
          font-family: 'IBM Plex Mono', monospace;
          font-weight: bold;
          color: var(--dark-blue);
          font-size: clamp(1.3rem, 0.5 * (1.23rem + 2dvh + 1.5dvw), 1.675rem);
          line-height: 2.25rem;
          text-align: center;
      }

      .text-body {
          font-size: clamp(0.75rem, 0.5 * (0.58rem + 1.33dvh + 1dvw), 1rem);
          line-height: 1.5rem;
      }

      .btn {
          padding: 10px 25px;
          cursor: pointer;
          border: none;
          font-family: 'Inter', sans-serif;
          text-align: center;
          border-radius: 4px;
          transition: all 0.2s ease-in-out;
      }

      .btn-primary {
          background-color: var(--primary);
          color: var(--dark-blue);
      }

      .btn-primary:hover {
          background-color: #00E07D;
      }

      .btn-secondary {
          background-color: #E0E0E0;
          color: var(--dark-blue);
      }

      .btn-secondary:hover {
          background-color: #C0C0C0;
      }

      .btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }

      .buttons {
          display: flex;
          justify-content: center;
          padding-top: 4rem;
          gap: 40px;
      }

      .logo-container, .research-logo-container {
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 8px;
      }

      .error-message {
          font-family: 'Inter', sans-serif;
          color: red;
      }

      .text-bold {
          font-weight: bold;
      }

      /* Research consent section styles */
      .research-info {
          margin-bottom: 1.5rem;
      }

      .research-heading {
          font-family: 'Inter', sans-serif;
          font-weight: bold;
          color: var(--dark-blue);
          font-size: 1rem;
          margin-bottom: 0.2rem;
          margin-top: 1rem;
      }

      .research-text {
          margin: 0;
      }

      .research-section {
          margin-bottom: 0.7rem;
      }

      .research-info ul {
          padding-left: 20px;
          margin-top: 0.2rem;
          margin-bottom: 0.5rem;
      }

      .consent-options {
          display: flex;
          justify-content: center;
          flex-wrap: wrap;
          gap: 20px;
          /*margin-top: 2rem;*/
          margin-bottom: 3rem;
      }

      @media (max-width: 768px) {
          #research-consent-section {
              max-height: 100dvh;
          }
      }

      .research-consent-section-content {
          padding: 8px;
      }

      .section-container::-webkit-scrollbar {
          width: 8px;
      }

      .section-container::-webkit-scrollbar-track {
          background: transparent;
          margin-top: 120px;
      }

      .section-container::-webkit-scrollbar-thumb {
          background-color: #1E7166;
          border-radius: 4px;
      }

      /* Consent checkboxes alignment */
      .consent-checkbox-label {
          display: flex;
          align-items: flex-start;
          gap: var(--consent-checkbox-gap);
          margin: 10px 0;
          cursor: pointer;
      }

      .consent-checkbox-label a {
          color: #002147;
      }

      .consent-checkbox-label input[type="checkbox"] {
          margin: 2px 0 0 0; /* nudge checkbox to align with first line */
          width: var(--consent-checkbox-size);
          height: var(--consent-checkbox-size);
          vertical-align: top;
      }

      /* Custom checkbox styling for exact look */
      .consent-checkbox {
          -webkit-appearance: none;
          appearance: none;
          margin: 2px 0 0 0;
          width: 18px;
          height: 18px;
          border: 2px solid #000; /* MUI-like default icon color */
          border-radius: 3px;
          background-color: #FFFFFF;
          display: inline-grid;
          place-content: center;
          box-sizing: border-box;
          transition: background-color 120ms cubic-bezier(0.4, 0, 0.2, 1),
          border-color 120ms cubic-bezier(0.4, 0, 0.2, 1),
          box-shadow 120ms cubic-bezier(0.4, 0, 0.2, 1);
      }

      /* Indent blocks to align with the label text (checkbox width + gap) */
      .consent-align {
          margin-left: calc(var(--consent-checkbox-size) + var(--consent-checkbox-gap));
      }

      .consent-checkbox:checked {
          background-color: var(--primary);
          border-color: var(--primary);
      }

      /*style the internal tick*/
      .consent-checkbox:checked::after {
          content: "";
          width: 6px;
          height: 10px;
          border: solid #FFFFFF;
          border-width: 0 2px 2px 0;
          transform: rotate(45deg);
          margin-top: -4px;
      }


      /* Focus-visible ring for keyboard users */
      .consent-checkbox:focus-visible {
          outline: none;
          box-shadow: 0 0 0 3px rgba(0, 255, 145, 0.35);
      }

      .consent-checkbox:disabled {
          opacity: 0.38;
          cursor: not-allowed;
      }

      /*  Snackbar   */
      #snackbar-notification {
          visibility: hidden;
          background-color: #E8F5E9; /* primary light green */
          color: #1E7166; /*primary dark green */
          text-align: center;
          border-radius: 4px;
          padding: 20px;
          position: fixed;
          height: auto;
          z-index: 1;
          top: 30px;
          right: 30px;
          font-size: 17px;
          align-self: center;
          margin: 10px;
          box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2),
          0px 6px 10px 0px rgba(0, 0, 0, 0.14),
          0px 1px 18px 0px rgba(0, 0, 0, 0.12); /* Mui snackbar shadow */
      }

      #snackbar-notification.show {
          visibility: visible;
          -webkit-animation: fadein 0.5s, fadeout 0.5s 4.5s;
          animation: fadein 0.5s, fadeout 0.5s 4.5s;
      }

      @-webkit-keyframes fadein {
          from {
              top: 0;
              opacity: 0;
          }
          to {
              top: 30px;
              opacity: 1;
          }
      }

      @keyframes fadein {
          from {
              top: 0;
              opacity: 0;
          }
          to {
              top: 30px;
              opacity: 1;
          }
      }

      @-webkit-keyframes fadeout {
          from {
              top: 30px;
              opacity: 1;
          }
          to {
              top: 0;
              opacity: 0;
          }
      }

      @keyframes fadeout {
          from {
              top: 30px;
              opacity: 1;
          }
          to {
              top: 0;
              opacity: 0;
          }
      }
  </style>
</head>
<body>
<div id="snackbar-notification">Login credentials have been sent to your email.</div>
<div>
  <div class="container">
    <div class="content">
      <div class="logo-container">
        <img src="/logo.svg" alt="Compass Logo" width="200" height="70" />
      </div>
      <section id="chat-page-container">
        <div style="width: 100vw; height: 100vh;" id="chat-page-container-iframe">
          <iframe src="about:blank" title="Compass Chat Application" style="width: 100%; height: 100%;"></iframe>
        </div>
      </section>

      <section id="research-consent-section" class="section-container text-body" style="display: none;">
        <div class="research-consent-section-content">
          <div class="research-logo-container">
            <img src="/logo.svg" alt="Compass Logo" width="200" height="100" />
          </div>
          <div>
            <p class="text-bold">Before we start, we would like to inform you about the research, your rights, and your
              benefits. Please agree or disagree to participate at the end of the page.</p>
            <div class="research-info">
              <div class="research-section">
                <p class="research-heading">Title of Research</p>
                <p class="research-text">AI-driven Career Counseling</p>
              </div>
              <div class="research-section">
                <p class="research-heading">Who is Doing This Study?</p>
                <p class="research-text">Researchers from Tabiya, the University of Oxford, and the University of Cape
                  Town (UCT).</p>
              </div>
              <div class="research-section">
                <p class="research-heading">Why Are We Doing This Study?</p>
                <p class="research-text">We want to see if using Compass, an online tool, helps young people clearly
                  describe their skills and find better job opportunities.</p>
              </div>
              <div class="research-section">
                <p class="research-heading">What Do You Need to Do?</p>
                <ul>
                  <li>Complete an online conversation with Compass. It may take up to 1 hour.</li>
                  <li>You will be asked questions related to your skills, experiences, and career aspirations.</li>
                  <li>Your responses will be used to create a personalized CV.</li>
                  <li>After a few weeks, you will be contacted via phone to complete a short follow-up survey
                    (approximately 30 minutes).
                  </li>
                </ul>
              </div>
              <div class="research-section">
                <p class="research-heading">Is Participation Voluntary?</p>
                <p class="research-text">Yes, participating is your choice. You can skip questions or stop at any time
                  without any penalties.</p>
              </div>
              <div class="research-section">
                <p class="research-heading">Privacy and Confidentiality</p>
                <p class="research-text">Your information will remain confidential. Researchers will use your responses
                  without revealing your identity in any reports or presentations.</p>
              </div>
              <div class="research-section">
                <p class="research-heading">Compensation</p>
                <ul>
                  <li>You receive <span class="text-bold">R40-R50</span> airtime after finishing the online activity.</li>
                  <li>You receive an additional <span class="text-bold">R60</span> airtime after completing the
                    follow-up phone survey.
                  </li>
                </ul>
              </div>
              <div class="research-section">
                <p class="research-heading">Risks and Benefits</p>
                <p class="research-text">There are no known risks. Your participation helps improve job-search support
                  for youth in South Africa.</p>
              </div>
              <br />
              <div class="research-section">
                <div>
                  <label for="consent-checkbox-study" class="consent-checkbox-label">
                    <input type="checkbox" id="consent-checkbox-study" class="consent-checkbox" />
                    <span><strong>I consent to participate in this study. </strong></span>
                  </label>

                  <div class="consent-align">
                    <p class="research-text">By checking this box, you agree that:</p>
                    <div class="consent-align">
                      <ul>
                        <li>You have read and understood the information provided above.</li>
                        <li>You voluntarily agree to participate in this study.</li>
                        <li>Your information can be confidentially used for research.</li>
                        <li>You understand you can withdraw at any time without any penalty.</li>
                      </ul>
                    </div>
                  </div>
                  <div class="research-section" id="consent-checkboxes">
                    <label for="consent-checkbox-tc" class="consent-checkbox-label">
                      <input type="checkbox" id="consent-checkbox-tc" class="consent-checkbox" />
                      <span>I have read and accept the <a href="https://www.tabiya.org/compass-terms-privacy/"
                                                          target="_blank" rel="noopener noreferrer"><strong>Terms and Conditions</strong></a> of Compass.</span>
                    </label>
                  </div>
                  <div>
                    <label for="consent-checkbox-privacy" class="consent-checkbox-label">
                      <input type="checkbox" id="consent-checkbox-privacy" class="consent-checkbox" />
                      <span>I have read and accept the <a
                        href="https://www.tabiya.org/compass-terms-privacy#privacy-policy/" target="_blank"
                        rel="noopener noreferrer"><strong>Privacy Policy</strong></a> of Compass.</span>
                    </label>
                  </div>
                </div>
                <br />
                <div class="research-section">
                  <p class="research-heading">Questions?</p>
                  <p class="research-text">Email <span class="text-bold">jasmin.baier@tabiya.org</span> for questions or
                    concerns about the study.</p>
                </div>
              </div>
              <br />
              <div class="consent-options">
                <button id="consent-agree-btn" class="btn btn-primary" disabled>Continue</button>
                <button id="consent-disagree-btn" class="btn btn-secondary">Decline</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="initial-question" class="section-container text-body" style="display: none;">
        <div class="title">Thank you for joining our study and confirming your email.</div>
        <div>
          <p><span class="text-bold">Your next step:</span> a task related to your skills and previous work experiences
            as well as some initial questions.</p>
          <p><span class="text-bold">Required time:</span> up to 1 hour -- you can start it now or anytime in the next 2
            weeks by simply clicking the link in the E-Mail again.</p>
          <p>You’ll receive <strong>R40-R50</strong> airtime as a token of appreciation after finishing the task and
            another <strong>R60</strong>
            about 3 months later when you complete a phone survey with us.</p>
          <p class="text-bold">Do you have a stable internet connection and about 1 hour free right now?</p>
        </div>
        <div class="buttons">
          <button class="btn btn-primary" id="yes-btn">Yes</button>
          <button class="btn btn-secondary" id="no-btn">No</button>
        </div>
      </section>

      <section id="user-is-busy-section" class="section-container text-body" style="display: none;">
        <div class="title">No problem!</div>
        <div>
          <p>
            Please plan a time when you have a good internet connection and about an hour free.
          </p>
          <p>When you’re ready, simply click the link in your email again to continue. :) We thank you for
            participating!</p>
        </div>
        <div>
          <div class="buttons">
            <button class="btn btn-primary" id="return-home">I have got time</button>
          </div>
        </div>
      </section>

      <section id="decline-consent-section" class="section-container text-body" style="display: none;">
        <div>
          <p>
            We understand your decision. Thank you for your interest up to now. Feel free to contact us if you are
            interested in reconnecting in the future.
          </p>
          <div class="buttons">
            <button class="btn btn-primary" id="reconsider-btn">I've Changed My Mind</button>
          </div>
        </div>
      </section>

      <section id="invalid-query-params" style="display: none;" class="section-container text-body">
        <div>
          <div class="error-message">Invalid query parameters. Please provide email and externalUserId in the URL.</div>
        </div>
      </section>
      <section id="wait-a-moment" style="display: none;" class="section-container text-body">
        <div>
          <div class="title">Wait a moment......</div>
        </div>
      </section>
      <section id="server-error-message" style="display: none;" class="section-container text-body">
        <div>
          <div class="error-message" id="server-error-message-content">Unknown error occurred. Please try again later.
          </div>
        </div>
      </section>
    </div>
  </div>

</div>
<script defer src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script defer src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>

<script>
  // #############################################################
  // #                    CONSTANTS
  // #############################################################

  const IDS = {
    SECTIONS: {
      RESEARCH_CONSENT_SECTION: "research-consent-section",
      INITIAL_QUESTION: "initial-question",
      USER_IS_BUSY_SECTION: "user-is-busy-section",
      DECLINE_CONSENT_SECTION: "decline-consent-section",
      INVALID_QUERY_PARAMS: "invalid-query-params",
      SERVER_ERROR_MESSAGE: "server-error-message",
      WAIT_A_MOMENT: "wait-a-moment",
      CHAT_CONTAINER: "chat-page-container",
    },
    YES_BTN: "yes-btn",
    NO_BTN: "no-btn",
    RETURN_HOME_BTN: "return-home",
    CONSENT_AGREE_BTN: "consent-agree-btn",
    CONSENT_DISAGREE_BTN: "consent-disagree-btn",
    RECONSIDER_BTN: "reconsider-btn",
    CONSENT_CHECKBOX_STUDY: "consent-checkbox-study",
    CONSENT_CHECKBOX_TC: "consent-checkbox-tc",
    CONSENT_CHECKBOX_PRIVACY: "consent-checkbox-privacy",
  };

  const CHAT_PAGE_CONTAINER_IFRAME = "chat-page-container-iframe";

  const LOGO_CONTAINER = "logo-container";

  const ENV_KEYS = {
    CLIENT_ID: "client_id_0.0.1",
    TOKEN: "token_0.0.1",
    LOGIN_METHOD: "login_method_0.0.1",
  };

  const LOGIN_METHODS = {
    FIREBASE_EMAIL: "FIREBASE_EMAIL",
  };

  // #############################################################
  // #                    UTILITY - FUNCTIONS
  // #############################################################
  const sleep = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
  const getNextBackoff = (initial_backoff_ms, attempt) => {
    if (attempt <= 1) return 0;
    return initial_backoff_ms * 2 ** (attempt - 2);
  };

  const INITIAL_BACKOFF_MS = 1000;
  const MAX_ATTEMPTS = 4;
  const RETRY_STATUS_CODES = [
    429, // Too Many Requests
    502, // Bad Gateway
    503, // Service Unavailable
  ];

  async function fetchWithRetry(url, init) {
    let response;
    for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
      console.debug("customFetch: Attempt", attempt, "for URL:", url, ", at ", new Date().toISOString());

      response = await fetch(url, init);

      // if the request is successful, return the response
      // without retrying
      if (response.ok)
        return response;

      // if the response status is in retry status codes,
      // wait for some time and retry
      if (RETRY_STATUS_CODES.includes(response.status)) {
        const backOffMs = getNextBackoff(INITIAL_BACKOFF_MS, attempt + 1);
        await sleep(backOffMs);
        continue;
      }

      // otherwise, it is not for a retry to return the actual response
      return response;
    }

    console.warn(
      `customFetch: Reached max attempts (${MAX_ATTEMPTS}) without success.`,
    );

    return response;
  }

  /**
   * Retrieves URL parameters for email and externalUserId.
   *
   * @returns {{ email: string, externalUserId: string }}
   */
  function getUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);

    const email = urlParams.get("email");
    const externalUserId = urlParams.get("externalUserId");

    return { email, externalUserId };
  }

  /**
   * Loads the configuration script from the given source URL.
   */
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = src;
      script.onload = () => resolve(script);
      script.onerror = (e) => {
        console.error(`Failed to load script: ${src}`, e);
        reject(new Error(`Failed to load script: ${src}`));
      };
      document.head.appendChild(script);
    });
  }

  /**
   * Hides all sections.
   */
  function hideAllSections() {
    document.getElementById(IDS.SECTIONS.RESEARCH_CONSENT_SECTION).style.display = "none";
    document.getElementById(IDS.SECTIONS.INITIAL_QUESTION).style.display = "none";
    document.getElementById(IDS.SECTIONS.USER_IS_BUSY_SECTION).style.display = "none";
    document.getElementById(IDS.SECTIONS.DECLINE_CONSENT_SECTION).style.display = "none";
    document.getElementById(IDS.SECTIONS.INVALID_QUERY_PARAMS).style.display = "none";
    document.getElementById(IDS.SECTIONS.SERVER_ERROR_MESSAGE).style.display = "none";
    document.getElementById(IDS.SECTIONS.WAIT_A_MOMENT).style.display = "none";
    document.getElementById(IDS.SECTIONS.CHAT_CONTAINER).style.display = "none";
  }

  /**
   * Shows the specified section by its ID.
   *
   * @param {string} sectionId - The ID of the section to show.
   */
  function showSection(sectionId) {
    hideAllSections();
    document.getElementById(sectionId).style.display = "block";

    const logo = document.querySelector(`.${LOGO_CONTAINER}`);
    if (logo) {
      logo.style.display =
        sectionId === IDS.SECTIONS.CHAT_CONTAINER ||
        sectionId === IDS.SECTIONS.RESEARCH_CONSENT_SECTION
          ? "none" : "flex";
    }
  }

  function redirectToControlGroup(context) {
    window.location.href = context.configs.CONTROL_GROUP_REDIRECT_LINK;
    return true;
  }

  function redirectToStaticForm(context) {
    const staticFormLink = context.configs.STATIC_FORM_REDIRECT_LINK;
    if (!staticFormLink) {
      console.error("Static form redirect link is not configured.");
      showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
      const errorContainer = document.getElementById("server-error-message-content");
      if (errorContainer) {
        errorContainer.innerHTML = "Static form redirect link is not configured. Please contact support.";
      }
      return false;
    }
    window.location.href = staticFormLink;
    return true;
  }

  function getClientID() {
    let clientId = localStorage.getItem(ENV_KEYS.CLIENT_ID);
    if (!clientId) {
      try {
        clientId = window.crypto.randomUUID();
      } catch (_error) {
        // Use the math.random to generate a random string if the crypto API is not available.
        // Since it is not widely supported for older browser versions,
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID#browser_compatibility
        console.error("Failed to generate random UUID. Using a random string instead.", _error);
        clientId = Math.random().toString(36) + Math.random().toString(36);  // NOSONAR used for unique identifying a client
      }
      localStorage.setItem(ENV_KEYS.CLIENT_ID, clientId);
    }

    return clientId;
  }

  // #############################################################
  // #                    SENTRY INTEGRATION
  // #############################################################
  const SENTRY_CONFIG_DEFAULT = {
    tracesSampleRate: 1.0,
    replaysSessionSampleRate: 0,
    replaysOnErrorSampleRate: 1.0,
    replayIntegration: false,
    levels: ["error", "warn"],
  };

  function loadSentryConfig() {
    const enabledStr = window.tabiyaConfig?.FRONTEND_ENABLE_SENTRY ? atob(window.tabiyaConfig.FRONTEND_ENABLE_SENTRY) : "false";
    const dsn = window.tabiyaConfig?.FRONTEND_SENTRY_DSN ? atob(window.tabiyaConfig.FRONTEND_SENTRY_DSN) : "";
    const cfgStr = window.tabiyaConfig?.FRONTEND_SENTRY_CONFIG ? atob(window.tabiyaConfig.FRONTEND_SENTRY_CONFIG) : "";
    const errors = [];
    const warnings = [];
    let cfg = { ...SENTRY_CONFIG_DEFAULT };
    if (!cfgStr) {
      warnings.push("Sentry config is not available, reverting to default config");
    } else {
      try {
        const parsed = JSON.parse(cfgStr);
        cfg = {
          tracesSampleRate: parsed?.tracesSampleRate ?? SENTRY_CONFIG_DEFAULT.tracesSampleRate,
          replaysSessionSampleRate: parsed?.replaysSessionSampleRate ?? SENTRY_CONFIG_DEFAULT.replaysSessionSampleRate,
          replaysOnErrorSampleRate: parsed?.replaysOnErrorSampleRate ?? SENTRY_CONFIG_DEFAULT.replaysOnErrorSampleRate,
          replayIntegration: parsed?.replayIntegration ?? SENTRY_CONFIG_DEFAULT.replayIntegration,
          levels: parsed?.levels ?? SENTRY_CONFIG_DEFAULT.levels,
        };
      } catch (e) {
        errors.push(new Error("Error parsing Sentry config JSON, reverting to default config", { cause: e }));
      }
    }
    return { enabled: String(enabledStr).toLowerCase() === "true", dsn, cfg, errors, warnings };
  }

  function initSentryIfEnabled() {
    const { enabled, dsn, cfg, errors, warnings } = loadSentryConfig();
    if (!enabled) {
      console.info("Sentry is not enabled. Sentry will not be initialized.");
      return;
    }
    if (!dsn) {
      console.warn("Sentry is enabled but DSN is not available. Sentry will not be initialized.");
      return;
    }
    if (!window.Sentry || typeof window.Sentry.init !== "function") {
      console.warn("Sentry SDK not loaded. Sentry will not be initialized.");
      return;
    }

    const backendUrl = window.tabiyaConfig?.BACKEND_URL ? atob(window.tabiyaConfig.BACKEND_URL) : "";
    const environment = window.tabiyaConfig?.TARGET_ENVIRONMENT_NAME ? atob(window.tabiyaConfig.TARGET_ENVIRONMENT_NAME) : undefined;

    const integrations = [
      Sentry.browserTracingIntegration(),
      Sentry.feedbackIntegration({
        showBranding: false,
        autoInject: false,
        colorScheme: "light",
        enableScreenshot: true,
      }),
    ];
    if (typeof Sentry.captureConsoleIntegration === "function") {
      integrations.push(Sentry.captureConsoleIntegration({ levels: cfg.levels }));
    } else {
      console.info("Sentry captureConsoleIntegration not available in this bundle; skipping console capture integration.");
    }
    if (cfg.replayIntegration && typeof Sentry.replayIntegration === "function") {
      integrations.push(Sentry.replayIntegration());
    }

    Sentry.init({
      dsn: dsn,
      environment: environment,
      integrations: integrations,
      tracesSampleRate: cfg.tracesSampleRate,
      tracePropagationTargets: ["localhost", backendUrl].filter(Boolean),
      replaysSessionSampleRate: cfg.replaysSessionSampleRate,
      replaysOnErrorSampleRate: cfg.replaysOnErrorSampleRate,
      beforeSend(event, hint) {
        event.tags = {
          ...event.tags,
          client_id: getClientID(),
        };
        return event;
      },
    });

    // Set a session tag for client_id
    Sentry.setTag("client_id", getClientID());

    // Attach version info
    try {
      fetch("/data/version.json")
        .then((r) => (r.ok ? r.json() : null))
        .then((info) => {
          if (info && info.frontend) {
            Sentry.setContext("Frontend Version", info.frontend);
          }
        })
        .catch(() => {
        });
    } catch (err) {
      // if something goes wrong warn and exit
      console.warn("Something went wrong while setting sentry version context", err);
    }

    // Log any warnings/errors after init so they can be captured
    warnings.forEach((w) => console.warn(`Warning loading Sentry: ${w}`));
    errors.forEach((e) => console.error(`Error loading Sentry: ${e.message}`, e));
  }

  /**
   * Handles the case when the user is busy and cannot participate.
   *
   * It shows the 'no-response' section.
   */
  function handleUserIsBusy() {
    showSection(IDS.SECTIONS.USER_IS_BUSY_SECTION);
  }

  /**
   * Handle the user is ready to start to chat with compass.
   * @returns {Promise<void>}
   */
  async function handleYesClick(context) {
    console.debug("Using Context", context);
    try {
      showSection(IDS.SECTIONS.WAIT_A_MOMENT);

      const response = await fetchWithRetry(context.configs.RCT_BACKEND_API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": context.configs.RCT_BACKEND_API_KEY,
        },
        body: JSON.stringify(context.request),
      });

      console.log("done with fetch, response status:", response.status);

      const data = await response.json();
      if (!response.ok) {
        console.error("Error:", response);

        showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        document.getElementById("server-error-message-content").innerHTML = data.message;
        return;
      }

      const assignedGroup = data.group;

      if (assignedGroup === context.groups.NOT_USING_COMPASS) {
        redirectToControlGroup(context);
        return;
      }

      if (assignedGroup === context.groups.STATIC_FORM) {
        redirectToStaticForm(context);
        return;
      }

      if (assignedGroup !== context.groups.USING_COMPASS) {
        console.error("Invalid group:", assignedGroup);
        showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        return;
      }

      const credentials = data.credentials;

      firebase.initializeApp({
        apiKey: context.configs.RCT_FIREBASE_API_KEY,
        authDomain: atob(window.tabiyaConfig.FIREBASE_AUTH_DOMAIN),
      });

      const userCredential = await firebase.auth().signInWithEmailAndPassword(context.request.email, atob(credentials.password));
      const token = await userCredential.user.getIdToken();

      // Set the client ID and token in localStorage
      localStorage.setItem(ENV_KEYS.TOKEN, token);
      localStorage.setItem(ENV_KEYS.LOGIN_METHOD, LOGIN_METHODS.FIREBASE_EMAIL);

      showSection(IDS.SECTIONS.CHAT_CONTAINER);

      // Set chat iframe source and handle its load event
      const chatIframe = document.querySelector(`#${CHAT_PAGE_CONTAINER_IFRAME} iframe`);
      if (chatIframe) {
        chatIframe.onload = () => {
          handleShowSnackbarNotification();
          history.replaceState({}, document.title, "/#/");
        };
        chatIframe.src = "/#/";
      }
    } catch (error) {
      console.error("Error:", error);
      // Handle error as needed
      showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
    }
  }

  function handleReturnHome() {
    // show the initial question section again
    showSection(IDS.SECTIONS.INITIAL_QUESTION);
  }

  function handleShowSnackbarNotification() {
    const snackbar = document.getElementById("snackbar-notification");
    snackbar.className = "show";
    setTimeout(() => {
      snackbar.className = snackbar.className.replace("show", "");
    }, 5000);
  }

  async function recordTermsResponse(context, body) {
    const url = `${context.configs.RCT_BACKEND_API_URL}?external-user-id=${encodeURIComponent(context.request.externalUserId)}`;
    return await fetchWithRetry(url, {
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": context.configs.RCT_BACKEND_API_KEY,
      },
      body: JSON.stringify(body),
    });
  }

  async function handleConsentAgree(context) {
    try {
      const nowIso = new Date().toISOString();
      const response = await recordTermsResponse(context, { acceptedTc: nowIso });
      if (!response.ok) {
        const data = await response.text();
        console.error("Failed to record acceptance:", data);
        showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        document.getElementById("server-error-message-content").innerHTML = data.message || "Failed to record acceptance";
        return;
      }
      showSection(IDS.SECTIONS.INITIAL_QUESTION);
    } catch (err) {
      console.error("Error while recording acceptance:", err);
      showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
    }
  }

  async function handleConsentDisagree(context) {
    try {
      const nowIso = new Date().toISOString();
      const response = await recordTermsResponse(context, { rejectedTc: nowIso });
      if (!response.ok) {
        const data = await response.text();
        console.error("Failed to record rejection:", data);
        showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        document.getElementById("server-error-message-content").innerHTML = data.message || "Failed to record rejection";
        return;
      }
      showSection(IDS.SECTIONS.DECLINE_CONSENT_SECTION);
    } catch (err) {
      console.error("Error while recording rejection:", err);
      showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
    }
  }

  function handleReconsider() {
    // User changed their mind, show research consent section again
    showSection(IDS.SECTIONS.RESEARCH_CONSENT_SECTION);
  }

  function setupEventListeners(context) {
    document.getElementById("yes-btn").addEventListener("click", handleYesClick.bind(null, context));
    document.getElementById("no-btn").addEventListener("click", handleUserIsBusy);
    document.getElementById("return-home").addEventListener("click", handleReturnHome);
    document.getElementById(IDS.CONSENT_AGREE_BTN).addEventListener("click", handleConsentAgree.bind(null, context));
    document.getElementById(IDS.CONSENT_DISAGREE_BTN).addEventListener("click", handleConsentDisagree.bind(null, context));
    document.getElementById(IDS.RECONSIDER_BTN).addEventListener("click", handleReconsider);

    const studyCb = document.getElementById(IDS.CONSENT_CHECKBOX_STUDY);
    const tcCb = document.getElementById(IDS.CONSENT_CHECKBOX_TC);
    const privacyCb = document.getElementById(IDS.CONSENT_CHECKBOX_PRIVACY);
    const continueBtn = document.getElementById(IDS.CONSENT_AGREE_BTN);

    function updateContinueEnabledState() {
      const allChecked = studyCb.checked && tcCb.checked && privacyCb.checked;
      continueBtn.disabled = !allChecked;
    }

    studyCb.addEventListener("change", updateContinueEnabledState);
    tcCb.addEventListener("change", updateContinueEnabledState);
    privacyCb.addEventListener("change", updateContinueEnabledState);

    // initialize disabled state explicitly
    updateContinueEnabledState();
  }

  function handleAlreadyLoggedIn() {
    const token = localStorage.getItem(ENV_KEYS.TOKEN);
    const loginMethod = localStorage.getItem(ENV_KEYS.LOGIN_METHOD);

    if (token && loginMethod) {
      console.debug("User is already logged in with method:", loginMethod);
      // Redirect to the main application or perform any other action
      window.location.replace("/#/");
      return true;
    } else {
      console.debug("No user is logged in, proceeding with screening.");
      return false;
    }
  }

  function handleAppLoaded() {
    console.debug("Application loaded successfully");

    const screeningConfig = window.screeningConfig;

    const RCT_BACKEND_API_URL = atob(screeningConfig.RCT_BACKEND_API_URL);
    const RCT_BACKEND_API_KEY = atob(screeningConfig.RCT_BACKEND_API_KEY);
    const RCT_FIREBASE_API_KEY = atob(screeningConfig.RCT_FIREBASE_API_KEY);
    const CONTROL_GROUP_REDIRECT_LINK = atob(screeningConfig.CONTROL_GROUP_REDIRECT_LINK);
    const STATIC_FORM_REDIRECT_LINK = screeningConfig.STATIC_FORM_REDIRECT_LINK ? atob(screeningConfig.STATIC_FORM_REDIRECT_LINK) : "";

    const { email, externalUserId } = getUrlParams();

    const context = {
      configs: {
        RCT_BACKEND_API_URL,
        RCT_BACKEND_API_KEY,
        RCT_FIREBASE_API_KEY,
        CONTROL_GROUP_REDIRECT_LINK,
        STATIC_FORM_REDIRECT_LINK,
      },
      groups: {
        USING_COMPASS: atob(screeningConfig.USER_GROUP_USING_COMPASS),
        NOT_USING_COMPASS: atob(screeningConfig.USER_GROUP_NOT_USING_COMPASS),
        STATIC_FORM: screeningConfig.USER_GROUP_STATIC_FORM ? atob(screeningConfig.USER_GROUP_STATIC_FORM) : "static_form",
      },
      request: {
        email,
        externalUserId,
        clientId: getClientID(),
      },
    };

    // Setup event listeners after configs are loaded
    setupEventListeners(context);

    // Before showing anything, check consent/group status and redirect accordingly
    checkConsentAndRedirect(context);
  }

  async function checkConsentAndRedirect(context) {
    try {
      const url = `${context.configs.RCT_BACKEND_API_URL}?external-user-id=${encodeURIComponent(context.request.externalUserId)}`;
      const response = await fetchWithRetry(url, {
        method: "GET",
        headers: { "x-api-key": context.configs.RCT_BACKEND_API_KEY },
      });

      // User not found, show consent screen
      if (response.status === 404) {
        showSection(IDS.SECTIONS.RESEARCH_CONSENT_SECTION);
        return;
      }

      // Handle server errors
      if (!response.ok) {
        showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        return;
      }

      const data = await response.json();
      const { acceptedTc, rejectedTc, group, compassUserId } = data;

      if (acceptedTc && group) {
        // User has accepted and has a group redirect accordingly
        if (group === context.groups.USING_COMPASS) {
        // check if credentials were created
            if (!compassUserId) {
                // User was randomized into compass but credentials weren't created, retry registration
                return showSection(IDS.SECTIONS.INITIAL_QUESTION);
            }
          // user has credentials, redirect to compass
          window.location.replace("/#/");
        } else if (group === context.groups.NOT_USING_COMPASS) {
          redirectToControlGroup(context);
        } else if (group === context.groups.STATIC_FORM) {
          redirectToStaticForm(context);
        } else {
          console.error("Unknown group:", group);
          showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
        }
        return;
      } else if (acceptedTc) {
        // User has accepted, but no group show initial question
        return showSection(IDS.SECTIONS.INITIAL_QUESTION);
      } else if (rejectedTc) {
        // User has rejected, show a decline section
        return showSection(IDS.SECTIONS.DECLINE_CONSENT_SECTION);
      } else {
        // User has not accepted or rejected, show consent section
        return showSection(IDS.SECTIONS.RESEARCH_CONSENT_SECTION);
      }

    } catch (err) {
      console.error("Failed to check consent/group status:", err);
      showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
    }
  }

  // #############################################################
  // #                    MAIN Entry Point
  // #############################################################
  // Show "wait-a-moment" section on first render
  showSection(IDS.SECTIONS.WAIT_A_MOMENT);
  document.addEventListener("DOMContentLoaded", function() {
    // Initialize Sentry as early as possible after env is loaded
    initSentryIfEnabled();

    // First check if the user is already logged in, and log them in if so.
    const alreadyLoggedIn = handleAlreadyLoggedIn();
    if (alreadyLoggedIn) {
      return;
    }

    // Get URL parameters
    const { email, externalUserId } = getUrlParams();

    if (!email || !externalUserId) {
      console.error("Email and externalUserId are required in the URL parameters.");
      showSection(IDS.SECTIONS.INVALID_QUERY_PARAMS);
      return;
    }

    const frontendFeatures = JSON.parse(atob(window.tabiyaConfig.FRONTEND_FEATURES));
    const screeningConfigPath = frontendFeatures.screening.config.config_buckets_url;

    loadScript(screeningConfigPath)
      .then(handleAppLoaded)
      .catch((error) => {
        // On error, retry one more time
        console.error("Failed to load screening config, retrying one more time...", error);
        loadScript(screeningConfigPath)
          .then(handleAppLoaded)
          .catch((error) => {
            console.error(error);
            showSection(IDS.SECTIONS.SERVER_ERROR_MESSAGE);
          });
      });
  });
</script>
</body>
</html>
